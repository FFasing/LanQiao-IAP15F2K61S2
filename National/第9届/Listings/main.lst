C51 COMPILER V9.59.0.0   MAIN                                                              05/11/2024 22:28:51 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(3) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include <iic.h>
   3          #include <onewire.h>
   4          sbit ROW1=P3^0;
   5          sbit ROW2=P3^1;
   6          sbit ROW3=P3^2;
   7          sbit ROW4=P3^3;
   8          sbit COL1=P4^4;
   9          sbit COL2=P4^2;
  10          sbit COL3=P3^5;
  11          sbit COL4=P3^4;
  12          code unsigned char Seg_Table[] =
  13          {
  14             0xc0,//0
  15             0xf9,//1
  16             0xa4,//2
  17             0xb0,//3
  18             0x99,//4
  19             0x92,//5
  20             0x82,//6
  21             0xf8,//7
  22             0x80,//8
  23             0x90,//9
  24             0x88,//A
  25             0x83,//b
  26             0xc6,//C
  27             0xa1,//d
  28             0x86,//E
  29             0x8e,//F
  30             0xff,//16
  31             0xc1,//U 17
  32             0x89,//H 18
  33             0x8c//P 19
  34          };
  35          code unsigned char Seg_Wale[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80 };
  36          unsigned char index,seg_bus[]={16,16,16,16,16,16,16,16},point_bus[]={0,0,0,0,0,0,0,0};
  37          unsigned char dat_slow,seg_slow_down,key_slow_down,led_bus[]={0,0,0,0,0,0,0,0};
  38          unsigned char key_val,key_old,key_down,key_up;
  39          unsigned int freq;
  40          unsigned int v_rb2,v_set;
  41          unsigned int Timer_1000,Timer_800,Timer_200;
  42          float temperature;
  43          unsigned char flag_long=0;
  44          
  45          unsigned char word_mod=0;     //0-数据显示 1-数据回显 2-阈值
  46          unsigned char mod1_select=0;  //0-电压 1-频率 2-温度
  47          unsigned char mod2_select=0;  //0-电压 1-频率 2-温度
  48          unsigned char eeprom_save[6]; //0-电压 1\2-频率 3\4-温度
  49          void Delay20ms(void) //@12.000MHz
  50          {
  51   1         unsigned char data i, j;
  52   1      
  53   1         i = 234;
  54   1         j = 115;
C51 COMPILER V9.59.0.0   MAIN                                                              05/11/2024 22:28:51 PAGE 2   

  55   1         do
  56   1         {
  57   2            while (--j);
  58   2         } while (--i);
  59   1      }
  60          void Timer1_Init(void)     //1000微秒@12.000MHz
  61          {
  62   1         AUXR &= 0xBF;        //定时器时钟12T模式
  63   1         TMOD &= 0x0F;        //设置定时器模式
  64   1         TL1 = 0x18;          //设置定时初始值
  65   1         TH1 = 0xFC;          //设置定时初始值
  66   1         TF1 = 0;          //清除TF1标志
  67   1         TR1 = 1;          //定时器1开始计时
  68   1         ET1 = 1;
  69   1         EA = 1;
  70   1      }
  71          void Timer0_Init(void)     //1000微秒@12.000MHz
  72          {
  73   1         AUXR &= 0x7F;        //定时器时钟12T模式
  74   1         TMOD &= 0xF0;        //设置定时器模式
  75   1         TMOD |= 0x05;        
  76   1         TL0 = 0x00;          //设置定时初始值
  77   1         TH0 = 0x00;          //设置定时初始值
  78   1         TF0 = 0;          //清除TF0标志
  79   1         TR0 = 1;          //定时器0开始计时
  80   1      }
  81          void system_init(void)
  82          {
  83   1         eeprom_read(eeprom_save,1,6);
  84   1         Delay20ms();
  85   1         Timer1_Init();
  86   1         Timer0_Init();
  87   1         P2=P2&0x1f|0x80;
  88   1         P0=0xff;
  89   1         P2=P2&0x1f|0xa0;
  90   1         P0=0x00;
  91   1         P2=P2&0x1f;
  92   1      }
  93          void seg(unsigned char wale,valu,point)
  94          {
  95   1         P2=P2&0x1f|0xc0;
  96   1         P0=Seg_Wale[wale];
  97   1         P2=P2&0x1f|0xe0;
  98   1         P0=Seg_Table[16];
  99   1         P2=P2&0x1f|0xc0;
 100   1         P0=Seg_Wale[wale];
 101   1         P2=P2&0x1f|0xe0;
 102   1         P0=Seg_Table[valu];
 103   1         if(point) P0&=0x7f;
 104   1         P2=P2&0x1f;
 105   1      }
 106          unsigned char key(void)
 107          {
 108   1         unsigned char i=0;
 109   1         ROW1=ROW2=ROW3=ROW4=1;
 110   1         COL1=0;COL2=COL3=COL4=1;
 111   1         if(ROW4==0) i=4;
 112   1         if(ROW3==0) i=5;
 113   1         if(ROW2==0) i=6;
 114   1         if(ROW1==0) i=7;
 115   1         return i;
 116   1      }
C51 COMPILER V9.59.0.0   MAIN                                                              05/11/2024 22:28:51 PAGE 3   

 117          void led(unsigned char addr,enable)
 118          {
 119   1         unsigned char val=0x00,old=0xff;
 120   1         if(enable)
 121   1            val|=0x01<<addr;
 122   1         else
 123   1            val&=~(0x01<<addr);
 124   1         if(old!=val)
 125   1         {
 126   2            P2=P2&0x1f|0x80;
 127   2            P0=~val;
 128   2            P2=P2&0x1f;
 129   2            old=val;
 130   2         }
 131   1      }
 132          void dat_proc(void)
 133          {
 134   1         unsigned char V_RB2;
 135   1         if(dat_slow) return;
 136   1         dat_slow=1;
 137   1         
 138   1         V_RB2=ad_read(0x43);
 139   1         v_rb2=V_RB2;
 140   1         v_rb2=v_rb2*50/255;
 141   1         
 142   1         temperature=Temperature_Read();
 143   1         temperature*=100;
 144   1      }
 145          void led_proc(void)
 146          {
 147   1         unsigned char i;
 148   1         for(i=0;i<3;i++) led_bus[i]=0;
 149   1         if(word_mod==0)
 150   1         {
 151   2            switch(mod1_select)
 152   2            {
 153   3               case 2:
 154   3                  led_bus[0]=1;
 155   3               break;
 156   3               case 1:
 157   3                  led_bus[1]=1;
 158   3               break;
 159   3               case 0:
 160   3                  led_bus[2]=1;
 161   3               break;
 162   3            }
 163   2         }
 164   1      }
 165          void key_proc(void)
 166          {
 167   1         unsigned char eeprom;
 168   1         if(key_slow_down) return;
 169   1         key_slow_down=1;
 170   1         key_val=key();
 171   1         key_down=key_val&(key_val^key_old);
 172   1         key_up=~key_val&(key_val^key_old);
 173   1         key_old=key_val;
 174   1         switch(key_down)
 175   1         {
 176   2            case 4:
 177   2               if(word_mod==0) mod1_select++;
 178   2               if(word_mod==1) mod2_select++;
C51 COMPILER V9.59.0.0   MAIN                                                              05/11/2024 22:28:51 PAGE 4   

 179   2               if(mod1_select>=3) mod1_select=0;
 180   2               if(mod2_select>=3) mod2_select=0;
 181   2            break;
 182   2            case 5:
 183   2               if(word_mod==0)
 184   2               {
 185   3                  switch(mod1_select)
 186   3                  {
 187   4                     case 0:
 188   4                        eeprom=v_rb2;
 189   4                        eeprom_save[0]=eeprom;
 190   4                     break;
 191   4                     case 1:
 192   4                        eeprom=(freq/10000%10);
 193   4                        eeprom_save[5]=eeprom;
 194   4                        eeprom=0;
 195   4                        eeprom+=(freq/1000%10)*10;
 196   4                        eeprom+=(freq/100%10);
 197   4                        eeprom_save[1]=eeprom;
 198   4                        eeprom=0;
 199   4                        eeprom+=(freq/10%10)*10;
 200   4                        eeprom+=(freq%10);
 201   4                        eeprom_save[2]=eeprom;
 202   4                     break;
 203   4                     case 2:
 204   4                        eeprom=0;
 205   4                        eeprom+=((int)temperature/1000%10)*10;
 206   4                        eeprom+=((int)temperature/100%10);
 207   4                        eeprom_save[3]=eeprom;
 208   4                        eeprom=0;
 209   4                        eeprom+=((int)temperature/10%10)*10;
 210   4                        eeprom+=((int)temperature%10);
 211   4                        eeprom_save[4]=eeprom;
 212   4                     break;
 213   4                  }
 214   3                  eeprom_write(eeprom_save,1,6);
 215   3                  Delay20ms();
 216   3               }
 217   2            break;
 218   2            case 6:
 219   2               if(word_mod==2) 
 220   2               {
 221   3                  flag_long=1;
 222   3                  v_set++;
 223   3               }
 224   2               else word_mod=1;
 225   2            break;
 226   2            case 7:
 227   2               if(word_mod!=2)
 228   2               word_mod=2;
 229   2               else 
 230   2               word_mod=0;
 231   2            break;
 232   2         }
 233   1         if(key_up==6&&word_mod==2) 
 234   1         {
 235   2            Timer_800=0;
 236   2            flag_long=0;
 237   2         }
 238   1      }
 239          void seg_proc(void)
 240          {
C51 COMPILER V9.59.0.0   MAIN                                                              05/11/2024 22:28:51 PAGE 5   

 241   1         unsigned char eeprom;
 242   1         unsigned char i;
 243   1         if(seg_slow_down) return;
 244   1         seg_slow_down=1;
 245   1         for(i=0;i<8;i++)
 246   1         {
 247   2            seg_bus[i]=16;
 248   2            point_bus[i]=0;
 249   2         }
 250   1         if(word_mod==0)switch(mod1_select)
 251   1         {
 252   2            case 0:
 253   2               seg_bus[0]=17;
 254   2               seg_bus[6]=v_rb2/10%10;
 255   2               point_bus[6]=1;
 256   2               seg_bus[7]=v_rb2%10;
 257   2            break;
 258   2            case 1:
 259   2               seg_bus[0]=15;
 260   2               seg_bus[3]=freq/10000%10;
 261   2               seg_bus[4]=freq/1000%10;
 262   2               seg_bus[5]=freq/100%10;
 263   2               seg_bus[6]=freq/10%10;
 264   2               seg_bus[7]=freq%10;
 265   2            break;
 266   2            case 2:
 267   2               seg_bus[0]=12;
 268   2               seg_bus[4]=(int)temperature/1000%10;
 269   2               seg_bus[5]=(int)temperature/100%10;
 270   2               point_bus[5]=1;
 271   2               seg_bus[6]=(int)temperature/10%10;
 272   2               seg_bus[7]=(int)temperature%10;
 273   2            break;
 274   2         }
 275   1         if(word_mod==1)
 276   1         {
 277   2            seg_bus[0]=18;
 278   2            switch(mod2_select)
 279   2            {
 280   3            case 0:
 281   3               seg_bus[1]=17;
 282   3               point_bus[6]=1;
 283   3               eeprom=eeprom_save[0];
 284   3               seg_bus[6]=eeprom/10%10;
 285   3               seg_bus[7]=eeprom%10;
 286   3            break;
 287   3            case 1:
 288   3               seg_bus[1]=15;
 289   3               eeprom=eeprom_save[5];
 290   3               seg_bus[3]=eeprom%10;
 291   3               eeprom=eeprom_save[1];
 292   3               seg_bus[4]=eeprom/10%10;
 293   3               seg_bus[5]=eeprom%10;
 294   3               eeprom=eeprom_save[2];
 295   3               seg_bus[6]=eeprom/10%10;
 296   3               seg_bus[7]=eeprom%10;
 297   3            break;
 298   3            case 2:
 299   3               seg_bus[1]=12;
 300   3               point_bus[5]=1;
 301   3               eeprom=eeprom_save[3];
 302   3               seg_bus[4]=eeprom/10%10;
C51 COMPILER V9.59.0.0   MAIN                                                              05/11/2024 22:28:51 PAGE 6   

 303   3               seg_bus[5]=eeprom%10;
 304   3               eeprom=eeprom_save[4];
 305   3               seg_bus[6]=eeprom/10%10;
 306   3               seg_bus[7]=eeprom%10;
 307   3            break;
 308   3            }
 309   2         }
 310   1         if(word_mod==2)
 311   1         {
 312   2            seg_bus[0]=19;
 313   2            seg_bus[6]=v_set/10%10;
 314   2            point_bus[6]=1;
 315   2            seg_bus[7]=v_set%10;
 316   2         }
 317   1      }
 318          void Timer1_server(void) interrupt 3
 319          {
 320   1         if(++dat_slow==500) dat_slow=0;
 321   1         if(++seg_slow_down==50) seg_slow_down=0;
 322   1         if(++key_slow_down==100) key_slow_down=0;
 323   1         if(++index==8) index=0;
 324   1         seg(index,seg_bus[index],point_bus[index]);
 325   1         led(index,led_bus[index]);
 326   1         key_proc();seg_proc();led_proc();
 327   1         if(++Timer_1000==1000)
 328   1         {
 329   2            Timer_1000=0;
 330   2            TR0=0;
 331   2            freq=(TH0<<8)|TL0;
 332   2            TL0=TH0=0;
 333   2            TR0=1;
 334   2         }
 335   1         if(flag_long)
 336   1         {
 337   2            if(++Timer_800==800)
 338   2            {
 339   3               if(flag_long==2) v_set++;
 340   3               Timer_800=0;
 341   3               flag_long=2;
 342   3            }
 343   2         }
 344   1         if(v_set>50) v_set=1;
 345   1         if(v_set<v_rb2)
 346   1         {
 347   2            if(++Timer_200==200)
 348   2            {
 349   3               Timer_200=0;
 350   3               led_bus[7]^=1;
 351   3            }
 352   2         }
 353   1         else led_bus[7]=0;
 354   1      }
 355          void main()
 356          {
 357   1         system_init();
 358   1         while(1)
 359   1         {
 360   2            dat_proc();
 361   2         }
 362   1      }


C51 COMPILER V9.59.0.0   MAIN                                                              05/11/2024 22:28:51 PAGE 7   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1631    ----
   CONSTANT SIZE    =     28    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     58       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
