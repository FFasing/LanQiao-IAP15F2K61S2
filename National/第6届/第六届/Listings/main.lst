C51 COMPILER V9.59.0.0   MAIN                                                              05/02/2024 01:42:07 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(3) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <STC15F2K60S2.H>//2h15min
   2          #include <intrins.h>
   3          #include <iic.h>
   4          
   5          sbit US_TX=P1^0;
   6          sbit US_RX=P1^1;
   7          
   8          sbit ROW1=P3^0;
   9          sbit ROW2=P3^1;
  10          sbit ROW3=P3^2;
  11          sbit ROW4=P3^3;
  12          sbit COL1=P4^4;
  13          sbit COL2=P4^2;
  14          sbit COL3=P3^5;
  15          sbit COL4=P3^4;
  16          
  17          
  18          code unsigned char Seg_Table[] =
  19          {
  20             0xc0,//0
  21             0xf9,//1
  22             0xa4,//2
  23             0xb0,//3
  24             0x99,//4
  25             0x92,//5
  26             0x82,//6
  27             0xf8,//7
  28             0x80,//8
  29             0x90,//9
  30             0x88,//A
  31             0x83,//b
  32             0xc6,//C
  33             0xa1,//d
  34             0x86,//E
  35             0x8e,//F
  36             0xff//16
  37          };
  38          code unsigned char Seg_Wale[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  39          unsigned char seg_slow_down,key_slow_down;
  40          unsigned char seg_buf[]={16,16,16,16,16,16,16,16};
  41          unsigned char seg_index;
  42          unsigned char key_val,key_old,key_up,key_down;
  43          unsigned char led_buf[]={0,0,0,0,0,0,0,0};
  44          unsigned char V_RB2=0;//50-0
  45          bit V_RB2_CT_500,C_Transmit;
  46          unsigned int Time_1000,Time_500,transmit_time,ad_wait;
  47          unsigned char distance;
  48          unsigned char freight=1;
  49          unsigned char mod3_count;
  50          bit seg_flash_flag;
  51          
  52          bit freight_flag=0;
  53          bit urgent_stop=0;
  54          unsigned char work_mod=0;//0-空载过载 1-类型判断 2-货物传送
C51 COMPILER V9.59.0.0   MAIN                                                              05/02/2024 01:42:07 PAGE 2   

  55          unsigned char RELAY=0,BEEP=0;
  56          unsigned char transmit_time_set[2]={2,4};
  57          
  58          void Delay20us()     //@20.000MHz
  59          {
  60   1         unsigned char i;
  61   1      
  62   1         _nop_();
  63   1         _nop_();
  64   1         i = 97;
  65   1         while (--i);
  66   1      }
  67          void system_init()
  68          {
  69   1         P2 = P2 & 0x1f | 0x80;//led
  70   1         P0 = 0xff;
  71   1         P2 = P2 & 0x1f | 0xa0;//other
  72   1         P0 = 0x00;
  73   1         P2 = P2 & 0x1f;
  74   1      }
  75          void Timer1Init(void)      //1毫秒@12.000MHz
  76          {
  77   1         AUXR &= 0xBF;     //定时器时钟12T模式
  78   1         TMOD &= 0x0F;     //设置定时器模式
  79   1         TL1 = 0x18;    //设置定时初值
  80   1         TH1 = 0xFC;    //设置定时初值
  81   1         TF1 = 0;    //清除TF1标志
  82   1         TR1 = 1;    //定时器1开始计时
  83   1         ET1 = 1;
  84   1         EA =1;
  85   1      }
  86          void seg(unsigned char wale,valu)
  87          {
  88   1         P2 = P2 & 0x1f | 0xc0;
  89   1         P0 = Seg_Wale[wale];
  90   1         P2 = P2 & 0x1f | 0xe0;
  91   1         P0 = Seg_Table[16];
  92   1         
  93   1         P2 = P2 & 0x1f | 0xc0;
  94   1         P0 = Seg_Wale[wale];
  95   1         P2 = P2 & 0x1f | 0xe0;
  96   1         P0 = Seg_Table[valu];
  97   1         P2 = P2 & 0x1f;
  98   1      }
  99          void led(unsigned char addr,enable)
 100          {
 101   1         unsigned char val=0x00,old=0xff;
 102   1         if(enable)
 103   1            val|=0x01<<addr;
 104   1         else
 105   1            val&=~(0x01<<addr);
 106   1         if(old!=val)
 107   1         {
 108   2            P2 = P2 & 0x1f | 0x80;//led
 109   2            P0 =~val;
 110   2            P2 = P2 & 0x1f;
 111   2            old=val;
 112   2         }
 113   1      }
 114          void relay_beep(unsigned char relay_enable,beep_enable)
 115          {
 116   1         unsigned char val=0x00,old=0xff;
C51 COMPILER V9.59.0.0   MAIN                                                              05/02/2024 01:42:07 PAGE 3   

 117   1         if(beep_enable)
 118   1            val|=0x40;
 119   1         else
 120   1            val&=~0x40;
 121   1         
 122   1         if(relay_enable)
 123   1            val|=0x10;
 124   1         else
 125   1            val&=~0x10;
 126   1         
 127   1         if(old!=val)
 128   1         {
 129   2            P2 = P2 & 0x1f | 0xa0;//other
 130   2            P0 = val;
 131   2            P2 = P2 & 0x1f;
 132   2            old=val;
 133   2         }
 134   1      }
 135          unsigned char key_read()
 136          {
 137   1         unsigned char temp=0;
 138   1         ROW1=ROW2=ROW3=ROW4=1;
 139   1         COL1=0;COL2=COL3=COL4=1;
 140   1         if(ROW4==0) temp=4;
 141   1         if(ROW3==0) temp=5;
 142   1         if(ROW2==0) temp=6;
 143   1         if(ROW1==0) temp=7;
 144   1         return temp;
 145   1      }
 146          void us_wale()
 147          {
 148   1         unsigned char i;
 149   1         for(i=0;i<10;i++)
 150   1         {
 151   2            US_TX=1;Delay20us();
 152   2            US_TX=0;
 153   2         }
 154   1      }
 155          unsigned char us_read()
 156          {
 157   1         TMOD&=0XF0;
 158   1         TH0=TL0=0;
 159   1         us_wale();
 160   1         TR0=1;
 161   1         while(US_RX==1&&TF0==0);
 162   1         TR0=0;
 163   1         if(TF0)
 164   1         {
 165   2            TF0=0;
 166   2            return 0;
 167   2         }
 168   1         else
 169   1            return ((TH0<<8)|TL0)*0.017;
 170   1      }
 171          void led_proc()
 172          {
 173   1         
 174   1         if(V_RB2>=0&&V_RB2<10)  //空载
 175   1         {
 176   2            freight_flag=0;
 177   2            led_buf[0]=1;
 178   2         }
C51 COMPILER V9.59.0.0   MAIN                                                              05/02/2024 01:42:07 PAGE 4   

 179   1         else led_buf[0]=0;
 180   1         
 181   1         if(V_RB2>=10&&V_RB2<40)    //非空载
 182   1         {
 183   2            led_buf[1]=1;
 184   2            if(freight_flag==0&&work_mod==0||freight_flag==0&&work_mod==1) freight_flag=1;
 185   2         }
 186   1         else led_buf[1]=0;
 187   1            
 188   1         if(V_RB2>=40)           //过载
 189   1         {
 190   2            freight_flag=0;
 191   2            V_RB2_CT_500=1;
 192   2         }
 193   1         else V_RB2_CT_500=0;
 194   1         
 195   1         
 196   1         if(freight_flag==1)
 197   1         {
 198   2            work_mod=1;
 199   2            freight_flag=0;
 200   2         }
 201   1      }
 202          void key_proc()
 203          {
 204   1         if(key_slow_down) return;
 205   1         key_slow_down=0;
 206   1         key_val=key_read();
 207   1         key_down=key_val&(key_val^key_old);
 208   1         key_up=~key_val&(key_val^key_old);
 209   1         key_old=key_val;
 210   1         switch(key_down)
 211   1         {
 212   2            case 4:
 213   2               if(V_RB2>=10&&V_RB2<40)    //非空载
 214   2               {
 215   3                  work_mod=2;
 216   3                  C_Transmit=1;
 217   3                  transmit_time=0;
 218   3               }
 219   2            break;
 220   2            case 5:
 221   2               if(C_Transmit==1)    //运输中
 222   2               {
 223   3                  urgent_stop^=1;
 224   3               }
 225   2            break;
 226   2            case 6:
 227   2               if(V_RB2>=0&&V_RB2<10)  mod3_count++;//空载
 228   2               if(mod3_count==1) work_mod=3;
 229   2               if(mod3_count==4) 
 230   2               {
 231   3                  work_mod=0;
 232   3                  mod3_count=0;
 233   3               }
 234   2            break;
 235   2            case 7:
 236   2               if(V_RB2>=0&&V_RB2<10)  //空载
 237   2               {
 238   3                  if(mod3_count==2) transmit_time_set[0]++;
 239   3                  if(mod3_count==3) transmit_time_set[1]++;
 240   3                  if(transmit_time_set[0]==11) transmit_time_set[0]=1;
C51 COMPILER V9.59.0.0   MAIN                                                              05/02/2024 01:42:07 PAGE 5   

 241   3                  if(transmit_time_set[1]==11) transmit_time_set[1]=1;
 242   3                  eeprom_write(transmit_time_set,1,2);
 243   3               }
 244   2            break;
 245   2         }
 246   1      }
 247          void seg_proc()
 248          {
 249   1         unsigned char i;
 250   1         if(seg_slow_down) return;
 251   1         seg_slow_down=0;
 252   1         for(i=0;i<8;i++) seg_buf[i]=16;
 253   1         switch(work_mod)//0-空载过载 1-类型判断 2-货物传送 3-调整时间
 254   1         {
 255   2            case 0:
 256   2               
 257   2            break;
 258   2            case 1:
 259   2               seg_buf[0]=1;
 260   2               seg_buf[3]=distance/10%10;
 261   2               seg_buf[4]=distance%10;
 262   2               seg_buf[7]=freight;
 263   2            break;
 264   2            case 2:
 265   2               seg_buf[0]=2;
 266   2             
 267   2               if(freight==1)
 268   2               {
 269   3               seg_buf[6]=((int)transmit_time_set[0]*1000-transmit_time)/10000%10;
 270   3               seg_buf[7]=((int)transmit_time_set[0]*1000-transmit_time)/1000%10;
 271   3               }
 272   2               if(freight==2)
 273   2               {
 274   3               seg_buf[6]=((int)transmit_time_set[1]*1000-transmit_time)/10000%10;
 275   3               seg_buf[7]=((int)transmit_time_set[1]*1000-transmit_time)/1000%10;
 276   3               }
 277   2            break;
 278   2            case 3:
 279   2               seg_buf[0]=3;
 280   2               seg_buf[3]=(int)transmit_time_set[0]/10%10;
 281   2               seg_buf[4]=(int)transmit_time_set[0]%10;
 282   2            
 283   2               if(mod3_count==2) 
 284   2               {
 285   3                  seg_flash_flag?(seg_buf[3]=(int)transmit_time_set[0]/10%10):(seg_buf[3]=16);
 286   3                  seg_flash_flag?(seg_buf[4]=(int)transmit_time_set[0]%10):(seg_buf[4]=16);
 287   3               }
 288   2               else
 289   2               {
 290   3                  seg_buf[3]=(int)transmit_time_set[0]/10%10;
 291   3                  seg_buf[4]=(int)transmit_time_set[0]%10;
 292   3               }
 293   2               
 294   2               if(mod3_count==3) 
 295   2               {
 296   3                  seg_flash_flag?(seg_buf[6]=(int)transmit_time_set[1]/10%10):(seg_buf[6]=16);
 297   3                  seg_flash_flag?(seg_buf[7]=(int)transmit_time_set[1]%10):(seg_buf[7]=16);
 298   3               }
 299   2               else
 300   2               {
 301   3                  seg_buf[6]=(int)transmit_time_set[1]/10%10;
 302   3                  seg_buf[7]=(int)transmit_time_set[1]%10;
C51 COMPILER V9.59.0.0   MAIN                                                              05/02/2024 01:42:07 PAGE 6   

 303   3               }
 304   2            break;
 305   2         }
 306   1      }
 307          void T1_R(void) interrupt 3
 308          {
 309   1         if(++Time_1000==1000) Time_1000=0;
 310   1         if(++ad_wait==200) ad_wait=0;
 311   1         if(++seg_slow_down==50) seg_slow_down=0;
 312   1         if(++key_slow_down==100) key_slow_down=0;
 313   1         if(++seg_index==8) seg_index=0;
 314   1         seg(seg_index,seg_buf[seg_index]);
 315   1         led(seg_index,led_buf[seg_index]);
 316   1         relay_beep(RELAY,BEEP);
 317   1         key_proc();seg_proc();led_proc();
 318   1         if(V_RB2_CT_500)
 319   1         {
 320   2            BEEP=1;
 321   2            if(++Time_500==500)
 322   2            {
 323   3               Time_500=0;
 324   3               led_buf[2]^=1;
 325   3            }
 326   2         }
 327   1         else{led_buf[2]=0;BEEP=0;}
 328   1         
 329   1         if(mod3_count==2||mod3_count==3)
 330   1         {
 331   2            if(++Time_500==500)
 332   2            {
 333   3               Time_500=0;
 334   3               seg_flash_flag^=1;
 335   3            }
 336   2         }
 337   1         
 338   1         if(C_Transmit==1&&V_RB2>=10&&V_RB2<40)
 339   1         {
 340   2            if(urgent_stop==0)
 341   2            {
 342   3               led_buf[3]=0;
 343   3               RELAY=1;
 344   3               
 345   3               if(freight==1)
 346   3               if(++transmit_time==(int)transmit_time_set[0]*1000)
 347   3               {
 348   4                  freight_flag=0;
 349   4                  C_Transmit=0;
 350   4               }
 351   3               
 352   3               if(freight==2)
 353   3               if(++transmit_time==(int)transmit_time_set[1]*1000)
 354   3               {
 355   4                  freight_flag=0;
 356   4                  C_Transmit=0;
 357   4               }
 358   3            }
 359   2            else
 360   2            {
 361   3               RELAY=0;
 362   3               if(++Time_500==500)
 363   3               {
 364   4                  Time_500=0;
C51 COMPILER V9.59.0.0   MAIN                                                              05/02/2024 01:42:07 PAGE 7   

 365   4                  led_buf[3]^=1;
 366   4               }
 367   3            }
 368   2         }
 369   1         else{RELAY=0;C_Transmit=0;led_buf[3]=0;urgent_stop=0;
 370   2             if(freight==1)transmit_time=(int)transmit_time_set[0]*1000;
 371   2        else if(freight==2)transmit_time=(int)transmit_time_set[1]*1000;}
 372   1      }
 373          void main()
 374          {
 375   1         system_init();
 376   1         Timer1Init();
 377   1         //eeprom_write(transmit_time_set,1,2);
 378   1         eeprom_read(transmit_time_set,1,2);
 379   1         V_RB2=ad_read(0x43)*10/51;
 380   1         V_RB2=1;
 381   1         while(1)
 382   1         {
 383   2            if(ad_wait==0) V_RB2=ad_read(0x43)*10/51;
 384   2            if(work_mod==1&&Time_1000==0)
 385   2            {
 386   3               distance=us_read();
 387   3               if(distance<=30) freight=1;
 388   3               if(distance>30) freight=2;
 389   3            }
 390   2         }
 391   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1626    ----
   CONSTANT SIZE    =     25    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     40    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
