C51 COMPILER V9.59.0.0   MAIN                                                              05/18/2024 00:12:22 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(3) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include <iic.h>
   3          #include <intrins.h>
   4          
   5          sbit US_TX=P1^0;
   6          sbit US_RX=P1^1;
   7          
   8          sbit ROW1=P3^0;
   9          sbit ROW2=P3^1;
  10          sbit ROW3=P3^2;
  11          sbit ROW4=P3^3;
  12          sbit COL1=P4^4;
  13          sbit COL2=P4^2;
  14          sbit COL3=P3^5;
  15          sbit COL4=P3^4;
  16          
  17          code unsigned char Seg_Table[] =
  18          {
  19             0xc0,//0
  20             0xf9,//1
  21             0xa4,//2
  22             0xb0,//3
  23             0x99,//4
  24             0x92,//5
  25             0x82,//6
  26             0xf8,//7
  27             0x80,//8
  28             0x90,//9
  29             0x88,//A
  30             0x83,//b
  31             0xc6,//C
  32             0xa1,//d
  33             0x86,//E
  34             0x8e,//F
  35             0xff,//  16
  36             0x89,//H 17
  37             0x8c//P 18
  38          };
  39          code unsigned char Seg_Wale[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  40          unsigned char all_slow,index,seg_slow,key_slow,led_slow,dat_slow;
  41          unsigned char led_buf[]={0,0,0,0,0,0,0,0},
  42          point_buf[]={0,0,0,0,0,0,0,0},
  43          seg_buf[]={16,16,16,16,16,16,16,16};
  44          unsigned char key_v,key_o,key_d,key_u;
  45          unsigned int Timer_1000,Timer_1s,Timer_100ms;
  46          bit T1s_con;
  47          
  48          bit freq_con=0;
  49          bit relay_con;
  50          unsigned char  relay_num;
  51          
  52          unsigned int   freq;
  53          unsigned char  wetness;
  54          unsigned int   destance=45;
C51 COMPILER V9.59.0.0   MAIN                                                              05/18/2024 00:12:22 PAGE 2   

  55          unsigned int   freq_set=9000,
  56                         wetness_set=40,
  57                         destance_set=60;
  58          
  59          unsigned char  seg_mod; //0-freq 1-wetness 2-destance 3-set
  60          unsigned char  m0_set=0;      //0-HZ 1-KHZ
  61          unsigned char  m2_set=0;      //0-CM 1-M
  62          unsigned char  m3_set=0;      //0-freq_set 1-wetness_set 2-destance_set
  63          
  64          unsigned int PWM_count,PWM_D;
  65          bit motor_con;
  66          void Timer2_Init(void)     //1000微秒@12.000MHz
  67          {
  68   1         AUXR &= 0xFB;        //定时器时钟12T模式
  69   1         T2L = 0x00;          //设置定时初始值
  70   1         T2H = 0x00;          //设置定时初始值
  71   1         AUXR |= 0x10;        //定时器2开始计时
  72   1      }
  73          void Timer1_Init(void)     //100微秒@12.000MHz
  74          {
  75   1         AUXR &= 0x7F;        //定时器时钟12T模式
  76   1         TMOD &= 0x00;        //设置定时器模式
  77   1         TMOD |= 0X05;     
  78   1         TL1 = 0x9C;          //设置定时初始值
  79   1         TH1 = 0xFF;          //设置定时初始值
  80   1         TF1 = 0;          //清除TF0标志
  81   1         TR1 = 1;          //定时器0开始计时
  82   1         ET1 = 1;
  83   1         EA = 1;
  84   1      }
  85          void seg(unsigned char wale,valu,point)
  86          {
  87   1         P2=P2&0X1F|0XC0;
  88   1         P0=Seg_Wale[wale];
  89   1         P2=P2&0X1F|0XE0;
  90   1         P0=Seg_Table[16];
  91   1         
  92   1         P2=P2&0X1F|0XC0;
  93   1         P0=Seg_Wale[wale];
  94   1         P2=P2&0X1F|0XE0;
  95   1         P0=Seg_Table[valu];
  96   1         if(point) P0&=0x7f;
  97   1      }
  98          void key_read()
  99          {
 100   1         unsigned char i=0;
 101   1         ROW1=ROW2=ROW3=ROW4=1;
 102   1         COL1=0;COL2=COL3=COL4=1;
 103   1         if(ROW4==0) i=4;
 104   1         if(ROW3==0) i=5;
 105   1         if(ROW2==0) i=6;
 106   1         if(ROW1==0) i=7;
 107   1         key_v=i;
 108   1         key_d=key_v&(key_v^key_o);
 109   1         key_u=~key_v&(key_v^key_o);
 110   1         key_o=key_v;
 111   1      }
 112          void led(unsigned char addr,enable)
 113          {
 114   1         unsigned char v=0x00,o=0xff;
 115   1         if(enable)
 116   1            v|=0x01<<addr;
C51 COMPILER V9.59.0.0   MAIN                                                              05/18/2024 00:12:22 PAGE 3   

 117   1         else 
 118   1            v&=~(0x01<<addr);
 119   1         if(o!=v)
 120   1         {
 121   2            P2=P2&0X1F|0X80;
 122   2            P0=~v;
 123   2            o=v;
 124   2         }
 125   1      }
 126          void others(unsigned char relay_en,motor_en)
 127          {
 128   1         unsigned char v=0x00,o=0xff;
 129   1         if(relay_en)
 130   1            v|=0x10;
 131   1         else 
 132   1            v&=~0x10;
 133   1         if(motor_en)
 134   1            v|=0x20;
 135   1         else 
 136   1            v&=~0x20;
 137   1         if(o!=v)
 138   1         {
 139   2            P2=P2&0X1F|0XA0;
 140   2            P0=v;
 141   2            o=v;
 142   2         }
 143   1      }
 144          void freq_read()
 145          {
 146   1            if(++Timer_1000==1000)
 147   1            {
 148   2               Timer_1000=0;
 149   2               TR0=0;
 150   2               freq=(TH0<<8)|TL0;
 151   2               TH0=TL0=0;
 152   2               TR0=1;
 153   2            }
 154   1      }
 155          
 156          void Delay20us(void) //@12.000MHz
 157          {
 158   1         unsigned char data i;
 159   1      
 160   1         _nop_();
 161   1         _nop_();
 162   1         i = 57;
 163   1         while (--i);
 164   1      }
 165          void us_wave()
 166          {
 167   1         unsigned char i;
 168   1         for(i=0;i<10;i++)
 169   1         {
 170   2            US_TX=1;Delay20us();US_TX=0;
 171   2         }
 172   1      }
 173          
 174          void destance_read()
 175          {
 176   1         unsigned char temp,TF2=0;
 177   1         AUXR&=0xef;//1110 1111
 178   1         T2H=T2L=0;
C51 COMPILER V9.59.0.0   MAIN                                                              05/18/2024 00:12:22 PAGE 4   

 179   1         us_wave();
 180   1         AUXR|=0x10;//0001 0000
 181   1         while(US_RX==1&&TF2==0)
 182   1         {
 183   2            if(T2H==0xff&&T2L==0xff) 
 184   2            {
 185   3               T2H=T2L=0;
 186   3               TF2=1;
 187   3            }
 188   2         }
 189   1         AUXR&=0xef;//1110 1111
 190   1         temp=((T2H<<8)|T2L)*0.017;
 191   1         T2H=T2L=0;  
 192   1         destance = (char)temp;
 193   1      }
 194          void dat_proc()
 195          {
 196   1         float v_r,v_o,set;
 197   1         unsigned char V_out;
 198   1         if(dat_slow) return;
 199   1         dat_slow=1;
 200   1         
 201   1         v_r=voltage_read(0x43);
 202   1         wetness=(char)(v_r/51.0*20.0);
 203   1         
 204   1         set=(float)wetness_set;
 205   1         v_o=204/(80-set)*(v_r/51.0*20.0)*1.0+255.0-16320/(80-set)*1.0;
 206   1         V_out=(char)v_o;
 207   1         if(wetness<=wetness_set)   V_out=0;
 208   1         if(wetness>=80)               V_out=255;
 209   1         voltage_out(V_out);
 210   1         
 211   1         destance_read();
 212   1         if(destance>destance_set)
 213   1         {
 214   2            if(relay_con==0) relay_num++;
 215   2            relay_con=1;
 216   2         }
 217   1            else relay_con=0;
 218   1      }
 219          void led_proc()
 220          {
 221   1         unsigned char i;
 222   1         if(led_slow) return;
 223   1         led_slow=1;
 224   1         for(i=3;i<8;i++){led_buf[i]=0;}
 225   1         if(freq_set<freq) led_buf[3]=1;
 226   1         if(wetness_set<wetness) led_buf[4]=1;
 227   1         if(destance_set<destance) led_buf[5]=1;
 228   1      }
 229          void key_proc()
 230          {
 231   1         if(key_slow) return;
 232   1         key_slow=1;
 233   1         key_read();
 234   1         switch(key_d)
 235   1         {
 236   2            case 4:seg_mod++;if(seg_mod==4) seg_mod=0;break;
 237   2            case 5:
 238   2               if(seg_mod==3) {m3_set++;if(m3_set==3) m3_set=0;}
 239   2            break;
 240   2            case 6:  //+ freq_set,wetness_set,destance_set;
C51 COMPILER V9.59.0.0   MAIN                                                              05/18/2024 00:12:22 PAGE 5   

 241   2               if(seg_mod==3)
 242   2               {
 243   3                  if(m3_set==0) freq_set+=500;
 244   3                  if(m3_set==1) wetness_set+=10;
 245   3                  if(m3_set==2) destance_set+=10;
 246   3               }
 247   2               if(seg_mod==2) m2_set^=1;
 248   2            break;
 249   2            case 7:  //- freq_set,wetness_set,destance_set;
 250   2               if(seg_mod==3)
 251   2               {
 252   3                  if(m3_set==0) freq_set-=500;
 253   3                  if(m3_set==1) wetness_set-=10;
 254   3                  if(m3_set==2) destance_set-=10;
 255   3               }
 256   2               if(seg_mod==0) m0_set^=1;
 257   2               if(seg_mod==1) T1s_con=1;
 258   2            break;
 259   2         }
 260   1         if(key_u==7&&seg_mod==1) 
 261   1         {
 262   2            T1s_con=0;Timer_1s=0;
 263   2         }
 264   1      }
 265          void seg_proc()
 266          {
 267   1         unsigned char i;
 268   1         if(seg_slow) return;
 269   1         seg_slow=1;
 270   1         for(i=0;i<8;i++) {point_buf[i]=0;seg_buf[i]=16;}
 271   1         seg_buf[2]=PWM_D;
 272   1         switch(seg_mod)
 273   1         {
 274   2            case 0:
 275   2               if(m0_set==0)        //hz
 276   2               {
 277   3                  seg_buf[0]=15;
 278   3                  if(freq>=10000)   seg_buf[3]=freq/10000%10;
 279   3                  if(freq>=1000) seg_buf[4]=freq/1000%10;
 280   3                  if(freq>=100)  seg_buf[5]=freq/100%10;
 281   3                  if(freq>=10)      seg_buf[6]=freq/10%10;
 282   3                                 seg_buf[7]=freq%10;
 283   3               }
 284   2               if(m0_set==1)        //khz
 285   2               {
 286   3                  seg_buf[0]=15;
 287   3                  if(freq>=1000000) seg_buf[3]=freq/1000000%10;
 288   3                  if(freq>=100000)  seg_buf[4]=freq/100000%10;
 289   3                  if(freq>=10000)      seg_buf[5]=freq/10000%10;
 290   3                  if(freq>=1000)    seg_buf[6]=freq/1000%10;
 291   3                  else              seg_buf[6]=0;
 292   3                  point_buf[6] = 1;
 293   3                                    seg_buf[7]=freq/100%10;
 294   3               }
 295   2            break;
 296   2            case 1:                 //%RH
 297   2                  seg_buf[0]=17;
 298   2                  seg_buf[5]=wetness/100%10;
 299   2                  seg_buf[6]=wetness/10%10;
 300   2                  seg_buf[7]=wetness%10;
 301   2            break;
 302   2            case 2:
C51 COMPILER V9.59.0.0   MAIN                                                              05/18/2024 00:12:22 PAGE 6   

 303   2               if(m2_set==0)        //cm
 304   2               {
 305   3                  seg_buf[0]=10;
 306   3                  if(destance>=100) seg_buf[5]=destance/100%10;
 307   3                  if(destance>=10)  seg_buf[6]=destance/10%10;
 308   3                  if(destance>=0)      seg_buf[7]=destance%10;
 309   3               }
 310   2               if(m2_set==1)        //m
 311   2               {
 312   3                  seg_buf[0]=10;
 313   3                  if(destance>=100) seg_buf[5]=destance/100%10;
 314   3                  else              seg_buf[5]=0;
 315   3                  point_buf[5] = 1;
 316   3                  if(destance>=10)  seg_buf[6]=destance/10%10;
 317   3                  if(destance>=0)      seg_buf[7]=destance%10;
 318   3               }
 319   2            break;
 320   2            case 3: 
 321   2               seg_buf[0]=18;
 322   2               if(m3_set==0)        //freq_set
 323   2               {
 324   3                  seg_buf[1]=1;
 325   3                  if(freq_set>=10000)  seg_buf[5]=freq_set/10000%10;
 326   3                  if(freq_set>=1000)      seg_buf[6]=freq_set/1000%10;
 327   3                  else                 seg_buf[6]=0;
 328   3                  point_buf[6] = 1;
 329   3                                       seg_buf[7]=freq_set/100%10;
 330   3               }
 331   2               if(m3_set==1)        //wetness_set
 332   2               {
 333   3                  seg_buf[1]=2;
 334   3                  seg_buf[6]=wetness_set/10;
 335   3                  seg_buf[7]=wetness_set%10;
 336   3               }
 337   2               if(m3_set==2)        //destance_set
 338   2               {
 339   3                  seg_buf[1]=3;
 340   3                  if(destance_set>=100)   seg_buf[6]=destance_set/100%10;
 341   3                  else                 seg_buf[6]=0;
 342   3                  point_buf[6] = 1; 
 343   3                                       seg_buf[7]=destance_set/10%10;
 344   3               }
 345   2            break;
 346   2         }
 347   1      }
 348          void time1_isr() interrupt 3
 349          {
 350   1         if(++all_slow==10) 
 351   1         {
 352   2            all_slow=0;
 353   2            if(++index==8) index=0;
 354   2            if(++seg_slow==50) seg_slow=0;
 355   2            if(++key_slow==100) key_slow=0;
 356   2            if(++led_slow==150) led_slow=0;
 357   2            if(++dat_slow==300) dat_slow=0;
 358   2            if(T1s_con)
 359   2            {
 360   3               if(++Timer_1s==1000)
 361   3               {
 362   4                  Timer_1s=0;
 363   4                  T1s_con=0;
 364   4                  relay_num=0;
C51 COMPILER V9.59.0.0   MAIN                                                              05/18/2024 00:12:22 PAGE 7   

 365   4               }
 366   3            }
 367   2            freq_read();
 368   2            led_proc();key_proc();seg_proc();
 369   2            led(index,led_buf[index]);
 370   2            seg(index,seg_buf[index],point_buf[index]);
 371   2            if(++Timer_100ms==100) //0-freq 1-wetness 2-destance 3-set
 372   2            {
 373   3               Timer_100ms=0;
 374   3               if(seg_mod==0) led_buf[0]^=1;
 375   3               else led_buf[0]=0;
 376   3               if(seg_mod==1) led_buf[1]^=1;
 377   3               else led_buf[1]=0;
 378   3               if(seg_mod==2) led_buf[2]^=1;
 379   3               else led_buf[2]=0;
 380   3            }
 381   2         }
 382   1         if(freq_set<freq) PWM_D=8;
 383   1         else PWM_D=2;
 384   1         
 385   1         if(++PWM_count==10) PWM_count=0;
 386   1         
 387   1         if(PWM_count<PWM_D) motor_con=1;
 388   1         else motor_con=0;
 389   1         
 390   1         others(relay_con,motor_con);
 391   1      }
 392          void init()
 393          {
 394   1         Timer1_Init();
 395   1         Timer2_Init();
 396   1         P2=P2&0X1F|0X80;
 397   1         P0=0XFF;
 398   1         P2=P2&0X1F|0XA0;
 399   1         P0=0X00;
 400   1      }
 401          void main()
 402          {
 403   1         init();
 404   1         while(1)
 405   1         {
 406   2            dat_proc();
 407   2         }
 408   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2215    ----
   CONSTANT SIZE    =     27    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     60       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
