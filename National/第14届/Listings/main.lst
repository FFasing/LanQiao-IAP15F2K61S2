C51 COMPILER V9.59.0.0   MAIN                                                              05/19/2024 20:03:14 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(3) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include <iic.h>
   3          #include <intrins.h>
   4          #include <onewire.h>
   5          
   6          sbit US_TX=P1^0;
   7          sbit US_RX=P1^1;
   8          
   9          sbit ROW1=P3^0;
  10          sbit ROW2=P3^1;
  11          sbit ROW3=P3^2;
  12          sbit ROW4=P3^3;
  13          sbit COL1=P4^4;
  14          sbit COL2=P4^2;
  15          sbit COL3=P3^5;
  16          sbit COL4=P3^4;
  17          
  18          code unsigned char Seg_Table[] =
  19          {
  20             0xc0,//0
  21             0xf9,//1
  22             0xa4,//2
  23             0xb0,//3
  24             0x99,//4
  25             0x92,//5
  26             0x82,//6
  27             0xf8,//7
  28             0x80,//8
  29             0x90,//9
  30             0x88,//A
  31             0x83,//b
  32             0xc6,//C
  33             0xa1,//d
  34             0x86,//E
  35             0x8e,//F
  36             0xff,//  16
  37             0xbf,//- 17
  38             0x8c,//P 18
  39             0x8e//F 19
  40          };
  41          code unsigned char Seg_Wale[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  42          unsigned char seg_slow,key_slow,led_slow,dat_slow;
  43          seg_buf[]={16,16,16,16,16,16,16,16},
  44          index,led_buf[]={0,0,0,0,0,0,0,0},point_buf[]={0,0,0,0,0,0,0,0};
  45          unsigned char key_old,key_val,key_down,key_up;
  46          unsigned int Timer_100,Timer_2000,Timer_6000;
  47          bit T2S_CON,T6S_CON;
  48          
  49          float          temperature;
  50          float          destance;
  51          int            compare;
  52          float          V_wave;
  53          unsigned char  L_DAC;
  54          unsigned char  temperature_set,
C51 COMPILER V9.59.0.0   MAIN                                                              05/19/2024 20:03:14 PAGE 2   

  55                         destance_set;
  56          unsigned char  mod0_set;//0-cm 1-m
  57          unsigned char  mod1_set;//0-destance_set 1- temperature_set
  58          unsigned char  mod2_set;//0-compare 1-V_wave 2-L_DAC
  59          
  60          bit RELAY;
  61          unsigned char mod;//0-测距 1-参数 2-工厂
  62          
  63          bit ADC_CON=0;
  64          bit KEY_CON=1;
  65          bit RECORE_FLAG=0;
  66          float destance_save;
  67          void data_init()
  68          {
  69   1         mod=0;
  70   1         mod0_set=0;
  71   1         destance_set=40;
  72   1         temperature_set=30;
  73   1         compare=0;
  74   1         V_wave=340;
  75   1         L_DAC=10;
  76   1      }
  77          void Timer0_Init(void)     //1000微秒@12.000MHz
  78          {
  79   1         AUXR &= 0x7F;        //定时器时钟12T模式
  80   1         TMOD &= 0xF0;        //设置定时器模式
  81   1         TL0 = 0x18;          //设置定时初始值
  82   1         TH0 = 0xFC;          //设置定时初始值
  83   1         TF0 = 0;          //清除TF0标志
  84   1         TR0 = 1;          //定时器0开始计时
  85   1         ET0 = 1;
  86   1         EA = 1;
  87   1      }
  88          void init()
  89          {
  90   1         Timer0_Init();
  91   1         P2 = P2 & 0X1F | 0X80;
  92   1         P0 = 0XFF;
  93   1         P2 = P2 & 0X1F | 0XA0;
  94   1         P0 = 0X00;
  95   1      }
  96          void seg(unsigned char wale,valu,point)
  97          {
  98   1         P2 = P2 & 0X1F | 0XC0;
  99   1         P0 = Seg_Wale[wale];
 100   1         P2 = P2 & 0X1F | 0XE0;
 101   1         P0 = Seg_Table[16];
 102   1         
 103   1         P2 = P2 & 0X1F | 0XC0;
 104   1         P0 = Seg_Wale[wale];
 105   1         P2 = P2 & 0X1F | 0XE0;
 106   1         P0 = Seg_Table[valu];
 107   1         if(point) P0&=0X7F;
 108   1      } 
 109          void led(unsigned char addr,enable)
 110          {
 111   1         unsigned char v=0x00,o=0xff;
 112   1         if(enable)
 113   1            v|=0x01<<addr;
 114   1         else
 115   1            v&=~(0x01<<addr);
 116   1         if(o!=v){
C51 COMPILER V9.59.0.0   MAIN                                                              05/19/2024 20:03:14 PAGE 3   

 117   2         P2 = P2 & 0X1F | 0X80;
 118   2         P0 = ~v;
 119   2         o=v;
 120   2         }
 121   1      }
 122          void relay(unsigned char enable)
 123          {
 124   1         unsigned char v=0x00,o=0xff;
 125   1         if(enable)
 126   1            v|=0x10;
 127   1         else
 128   1            v&=~0x10;
 129   1         if(o!=v){
 130   2         P2 = P2 & 0X1F | 0XA0;
 131   2         P0 = v;
 132   2         o=v;
 133   2         }
 134   1      }
 135          void key()
 136          {
 137   1         unsigned char temp=0;
 138   1         ROW1=ROW2=ROW3=ROW4=1;
 139   1         COL1=0;COL2=COL3=COL4=1;
 140   1         if(ROW4==0) temp=4;
 141   1         if(ROW3==0) temp=5;
 142   1         COL2=0;COL1=COL3=COL4=1;
 143   1         if(ROW4==0) temp=8;
 144   1         if(ROW3==0) temp=9;
 145   1         if(ROW4==0&&ROW3==0) temp=1;
 146   1         key_val=temp;
 147   1         key_down=key_val&(key_val^key_old);
 148   1         key_up=~key_val&(key_val^key_old);
 149   1         key_old=key_val;
 150   1      }
 151          void Delay20us(void) //@20.000MHz
 152          {
 153   1         unsigned char data i;
 154   1      
 155   1         _nop_();
 156   1         _nop_();
 157   1         i = 97;
 158   1         while (--i);
 159   1      }
 160          void destance_read()
 161          {
 162   1         unsigned char i;
 163   1         TMOD &= 0X0F;
 164   1         TH1=TL1=0;
 165   1         for(i=0;i<10;i++)
 166   1         {
 167   2            US_TX=1;Delay20us();US_TX=0;
 168   2         }
 169   1         TR1=1;
 170   1         while(US_RX==1&&TF1==0);
 171   1         TR1=0;
 172   1         if(TF1==1)
 173   1         {
 174   2            TF1=0;
 175   2            destance=0;
 176   2         }
 177   1         else
 178   1         {
C51 COMPILER V9.59.0.0   MAIN                                                              05/19/2024 20:03:14 PAGE 4   

 179   2            destance=((TH1<<8)|TL1)*(V_wave/20000.0);
 180   2         }
 181   1         destance+=compare;
 182   1         if(destance<=0) destance=0;
 183   1      }
 184          void dat_limit()
 185          {//compare;V_wave;L_DAC;temperature_set,destance_set;
 186   1         if(destance_set<=10)    destance_set=10;
 187   1         if(destance_set>=90)    destance_set=90;
 188   1         
 189   1         if(temperature_set<=0)  temperature_set=0;
 190   1         if(temperature_set>=80)    temperature_set=80;
 191   1         
 192   1         if(compare<=-90)  compare=-90;
 193   1         if(compare>=90)   compare=90;
 194   1         
 195   1         if(V_wave<=10)       V_wave=10;
 196   1         if(V_wave>=9990)  V_wave=9990;
 197   1         
 198   1         if(L_DAC<=1)   L_DAC=1;
 199   1         if(L_DAC>=20)  L_DAC=20;
 200   1      }
 201          void led_p()
 202          {
 203   1         unsigned char i,temp;
 204   1         if(led_slow) return;
 205   1         led_slow=1;
 206   1         for(i=1;i<8;i++) led_buf[i]=0;
 207   1         if(mod!=2)
 208   1         {
 209   2            led_buf[0]=0;
 210   2            if(mod==0)
 211   2            {
 212   3               temp=destance;
 213   3               for(i=0;i<8;i++) led_buf[i]=(temp>>(7-i))&0x01;
 214   3            }
 215   2            if(mod==1) led_buf[7]=1;
 216   2         }
 217   1         if((destance_set-5)<=destance&&(destance_set+5)>=destance
 218   1           &&temperature_set>=temperature) RELAY=1;
 219   1         else RELAY=0;
 220   1      }
 221          void key_p()
 222          {
 223   1         if(key_slow) return;
 224   1         key_slow=1;key();
 225   1         switch(key_down)
 226   1         {
 227   2            case 4:
 228   2               mod++;if(mod>=3) mod=0;
 229   2            break;
 230   2            case 5:
 231   2               if(mod==0) mod0_set++;
 232   2               if(mod==1) mod1_set++;
 233   2               if(mod==2) mod2_set++;
 234   2               if(mod0_set>=2) mod0_set=0;
 235   2               if(mod1_set>=2) mod1_set=0;
 236   2               if(mod2_set>=3) mod2_set=0;
 237   2            break;
 238   2            case 8://++
 239   2               if(mod==0) T6S_CON=1;
 240   2               if(mod==1) switch(mod1_set)
C51 COMPILER V9.59.0.0   MAIN                                                              05/19/2024 20:03:14 PAGE 5   

 241   2               {
 242   3                  case 0:  destance_set+=10;    break;
 243   3                  case 1:  temperature_set++;      break;
 244   3               }
 245   2               if(mod==2) switch(mod2_set)
 246   2               {
 247   3                  case 0:  compare+=5; break;
 248   3                  case 1:  V_wave+=10; break;
 249   3                  case 2:  L_DAC++;    break;
 250   3               }
 251   2            break;
 252   2            case 9://--ADC_CON
 253   2               if(mod==0&&RECORE_FLAG==1) ADC_CON^=1;
 254   2               if(mod==1) switch(mod1_set)
 255   2               {
 256   3                  case 0:  destance_set-=10;    break;
 257   3                  case 1:  temperature_set--;      break;
 258   3               }
 259   2               if(mod==2) switch(mod2_set)
 260   2               {
 261   3                  case 0:  compare-=5; break;
 262   3                  case 1:  V_wave-=10; break;
 263   3                  case 2:  L_DAC--;    break;
 264   3               }
 265   2            break;
 266   2         }
 267   1         dat_limit();
 268   1         if(key_down==1)
 269   1         {
 270   2            T2S_CON=1;
 271   2            Timer_2000=0;
 272   2         }
 273   1         if(key_up==1)
 274   1         {
 275   2            T2S_CON=0;
 276   2            Timer_2000=0;
 277   2         }
 278   1      }
 279          void seg_p()
 280          {/*mod 0-测距 1-参数 2-工厂*/
 281   1         unsigned char i;
 282   1         int compare_temp;
 283   1         if(seg_slow) return;
 284   1         seg_slow=1;
 285   1         for(i=0;i<8;i++)
 286   1         {seg_buf[i]=16;point_buf[i]=0;}
 287   1         seg_buf[3]=key_down;
 288   1         if(mod==0)
 289   1         {//temperature destance
 290   2            switch(mod0_set)
 291   2            {//mod0_set 0-cm 1-m
 292   3               case 0:
 293   3                  seg_buf[0]=(int)temperature/10%10;
 294   3                  seg_buf[1]=(int)temperature%10;
 295   3                  point_buf[1]=1;
 296   3                  seg_buf[2]=(int)(temperature*10)%10;
 297   3               break;
 298   3               case 1:
 299   3                  seg_buf[0]=(int)temperature/100%10;
 300   3                  point_buf[0]=1;
 301   3                  seg_buf[1]=(int)temperature/10%10;
 302   3                  seg_buf[2]=(int)temperature%10;
C51 COMPILER V9.59.0.0   MAIN                                                              05/19/2024 20:03:14 PAGE 6   

 303   3               break;
 304   3            }
 305   2            seg_buf[3]=17;
 306   2            if(destance>=1000)   seg_buf[4]=(int)destance/1000%10;
 307   2            if(destance>=100)    seg_buf[5]=(int)destance/100%10;
 308   2            if(destance>=10)  seg_buf[6]=(int)destance/10%10;
 309   2            if(destance>=0)   seg_buf[7]=(int)destance%10;
 310   2         }
 311   1         if(mod==1)
 312   1         {//temperature_set,destance_set
 313   2            seg_buf[0]=18;
 314   2            switch(mod1_set)
 315   2            {//0-destance_set 1- temperature_set
 316   3               case 0:
 317   3                  seg_buf[1]=1;
 318   3                  seg_buf[6]=destance_set/10%10;
 319   3                  seg_buf[7]=destance_set%10;
 320   3               break;
 321   3               case 1:
 322   3                  seg_buf[1]=2;
 323   3                  seg_buf[6]=temperature_set/10%10;
 324   3                  seg_buf[7]=temperature_set%10;
 325   3               break;
 326   3            }
 327   2         }
 328   1         if(mod==2)
 329   1         {//compare V_wave L_DAC
 330   2            seg_buf[0]=19;
 331   2            switch(mod2_set)
 332   2            {//0-compare 1-V_wave 2-L_DAC
 333   3               case 0:
 334   3                  compare_temp=compare;
 335   3                  seg_buf[1]=1;
 336   3                  if(compare_temp<0)//- 17
 337   3                  {
 338   4                     compare_temp*=(-1);
 339   4                     if(compare_temp>=100)   seg_buf[4]=17;
 340   4                     if(compare_temp>=10)       seg_buf[5]=17;
 341   4                     if(compare_temp>0)      seg_buf[6]=17;
 342   4                  }
 343   3                  if(compare_temp>=100)      seg_buf[5]=compare_temp/100%10;
 344   3                  if(compare_temp>=10)    seg_buf[6]=compare_temp/10%10;
 345   3                  if(compare_temp>=0)     seg_buf[7]=compare_temp%10;
 346   3               break;
 347   3               case 1:
 348   3                  seg_buf[1]=2;
 349   3                  if(V_wave>=1000)  seg_buf[4]=(int)V_wave/1000%10;
 350   3                  if(V_wave>=100)      seg_buf[5]=(int)V_wave/100%10;
 351   3                  if(V_wave>=10)    seg_buf[6]=(int)V_wave/10%10;
 352   3                  if(V_wave>=0)     seg_buf[7]=(int)V_wave%10;
 353   3               break;
 354   3               case 2:
 355   3                  seg_buf[1]=3;
 356   3                  seg_buf[6]=L_DAC/10;
 357   3                  point_buf[6]=1;
 358   3                  seg_buf[7]=L_DAC%10;
 359   3               break;
 360   3            }
 361   2         }
 362   1      }
 363          void Timer0_Isr(void) interrupt 1
 364          {//seg_slow,key_slow,led_slo,dat_slow
C51 COMPILER V9.59.0.0   MAIN                                                              05/19/2024 20:03:14 PAGE 7   

 365   1         if(++seg_slow==50) seg_slow=0;
 366   1         if(++key_slow==100) key_slow=0;
 367   1         if(++led_slow==150) led_slow=0;
 368   1         if(++dat_slow==300) dat_slow=0;
 369   1         if(++index==8) index=0;
 370   1         seg(index,seg_buf[index],point_buf[index]);
 371   1         led(index,led_buf[index]);
 372   1         led_p();seg_p();relay(RELAY);
 373   1         if(KEY_CON) key_p();
 374   1         if(++Timer_100==100)
 375   1         {  if(mod==2) led_buf[0]^=1;
 376   2            Timer_100=0;
 377   2         }
 378   1         if(T2S_CON)
 379   1         {  if(++Timer_2000==2000)
 380   2            {
 381   3               T2S_CON=0;
 382   3               Timer_2000=0;
 383   3               data_init();
 384   3            }
 385   2         }
 386   1         else  Timer_2000=0;
 387   1         if(T6S_CON)
 388   1         {  KEY_CON=0;
 389   2            destance_save=destance;
 390   2            if(++Timer_6000==6000)
 391   2            {
 392   3               T6S_CON=0;
 393   3               Timer_6000=0;
 394   3               RECORE_FLAG=1;
 395   3               KEY_CON=1;
 396   3            }
 397   2         }
 398   1         else  Timer_6000=0;
 399   1      }
 400          void dat_p()
 401          {
 402   1         double VL,VO;
 403   1         if(dat_slow) return;
 404   1         dat_slow=1;
 405   1         VO=(0.625-0.0125*(float)L_DAC)*destance_save+1.125*(float)L_DAC-6.25;
 406   1         if(destance_save>=90) VO=50;
 407   1         if(destance_save<=10) VO=10;
 408   1         if(ADC_CON) voltage_out((char)(VO*5.1));
 409   1         
 410   1         destance_read();
 411   1         
 412   1         temperature=temperature_read();
 413   1      }
*** WARNING C280 IN LINE 402 OF main.c: 'VL': unreferenced local variable
 414          void main()
 415          {
 416   1         data_init();
 417   1         init();
 418   1         while(1)
 419   1         {
 420   2            dat_p();
 421   2         }
 422   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.59.0.0   MAIN                                                              05/19/2024 20:03:14 PAGE 8   

   CODE SIZE        =   2698    ----
   CONSTANT SIZE    =     28    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     89       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
