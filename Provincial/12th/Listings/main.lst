C51 COMPILER V9.59.0.0   MAIN                                                              03/31/2024 21:01:25 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\keil5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.l
                    -st) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include <onewire.h>
   3          #include <iic.h>
   4          
   5          sbit ROW1=P3^0;
   6          sbit ROW2=P3^1;
   7          sbit ROW3=P3^2;
   8          sbit ROW4=P3^3;
   9          sbit COL1=P4^4;
  10          sbit COL2=P4^2;
  11          sbit COL3=P3^5;
  12          sbit COL4=P3^4;
  13          
  14          code unsigned char Seg_Table[] =
  15          {
  16          0xc0,//0
  17          0xf9,//1
  18          0xa4,//2
  19          0xb0,//3
  20          0x99,//4
  21          0x92,//5
  22          0x82,//6
  23          0xf8,//7
  24          0x80,//8
  25          0x90,//9
  26          0xff,//10
  27          0x88,//A 11
  28          0xc6,//C 12
  29          0x8c,//P 13
  30          };
  31          code unsigned char Seg_Wale[]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  32          unsigned char key_slow_down,seg_slow_down,seg_num;
  33          unsigned char seg_show_mod=1;   //1-温度显示 2-参数设置 3-DAC输出
  34          unsigned char key_val,key_old,key_up,key_down;
  35          unsigned char seg_bus[]={10,10,10,10,10,10,10,10};
  36          unsigned char seg_point[]={0,0,0,0,0,0,0,0};
  37          unsigned char led_bus[]={0,0,0,0,0,0,0,0};
  38          float Temperature,Temperature_Set=25;
  39          int Set_Prepare;
  40          unsigned char V_out;
  41          float V_out_show;
  42          bit AD_mod=0;   //0-t_set(0`5)[1] 1-T()[2]
  43          
  44          void Timer0Init(void);
  45          void system_init();
  46          void seg_show(unsigned char wale,vula,point);
  47          unsigned char key_read();
  48          void led_read(unsigned char addr,enable);
  49          
  50          void AD_proc()
  51          {
  52   1              float temp;
  53   1              if(AD_mod==0)
  54   1              {
C51 COMPILER V9.59.0.0   MAIN                                                              03/31/2024 21:01:25 PAGE 2   

  55   2                      V_out=255;
  56   2                      if(Temperature<Temperature_Set) V_out=0;
  57   2                      V_out_show=(float)((float)V_out/255.0*5.0);
  58   2              }
  59   1              if(AD_mod==1)
  60   1              {
  61   2                      temp=(Temperature*3.0/20.0-2.0);
  62   2                      if(temp>=4.0) temp=4.0;
  63   2                      if(temp<=2.0) temp=2.0;
  64   2                      V_out_show=temp;
  65   2                      V_out=(int)V_out_show*255/5;
  66   2              }
  67   1              DA_Write(V_out);
  68   1      }
  69          void key_proc()
  70          {
  71   1              if(key_slow_down) return;
  72   1              key_slow_down=1;
  73   1              key_val=key_read();
  74   1              key_down=key_val&(key_val^key_old);
  75   1              key_up=~key_val&(key_val^key_old);
  76   1              key_old=key_val;
  77   1              switch(key_down)
  78   1              {
  79   2                      case 4:
  80   2                              if(seg_show_mod==1)
  81   2                                      Set_Prepare=Temperature_Set;
  82   2                              seg_show_mod++;
  83   2                              if(seg_show_mod==4) seg_show_mod=1;
  84   2                      break;
  85   2                      case 5:
  86   2                              AD_mod^=1;
  87   2                      break;
  88   2                      case 8:
  89   2                              if(seg_show_mod==2)
  90   2                              {
  91   3                                      Set_Prepare--;
  92   3                              }
  93   2                      break;
  94   2                      case 9:
  95   2                              if(seg_show_mod==2)
  96   2                              {
  97   3                                      Set_Prepare++;
  98   3                              }
  99   2                      break;
 100   2              }
 101   1              if(key_up==4&&seg_show_mod==3)  Temperature_Set=Set_Prepare;
 102   1      }
 103          void led_proc()
 104          {
 105   1              unsigned char i;
 106   1              for(i=0;i<8;i++) led_bus[i]=0;
 107   1              if(AD_mod==0) led_bus[0]=1;
 108   1              if(seg_show_mod==1) led_bus[1]=1;
 109   1              if(seg_show_mod==2) led_bus[2]=1;
 110   1              if(seg_show_mod==3) led_bus[3]=1;
 111   1              //if(V_out_show==5) led_bus[7]=1;
 112   1      }
 113          void seg_proc()
 114          {
 115   1              if(seg_slow_down) return;
 116   1              seg_slow_down=1;
C51 COMPILER V9.59.0.0   MAIN                                                              03/31/2024 21:01:25 PAGE 3   

 117   1              switch(seg_show_mod)
 118   1              {
 119   2                      case 1:
 120   2                              seg_bus[0]=12;
 121   2                              seg_bus[1]=10;
 122   2                              seg_bus[2]=10;
 123   2                              seg_bus[3]=10;
 124   2                              seg_bus[4]=(int)Temperature/10%10;
 125   2                              seg_bus[5]=(int)Temperature%10;
 126   2                                      seg_point[5]=1;
 127   2                              seg_bus[6]=(int)(Temperature*10.0)%10;
 128   2                              seg_bus[7]=(int)(Temperature*100.0)%10;
 129   2                      break;
 130   2                      case 2:
 131   2                              seg_bus[0]=13;
 132   2                              seg_bus[1]=10;
 133   2                              seg_bus[2]=10;
 134   2                              seg_bus[3]=10;
 135   2                              seg_bus[4]=10;
 136   2                              seg_bus[5]=10;
 137   2                                      seg_point[5]=0;
 138   2                              seg_bus[6]=(int)Set_Prepare/10%10;
 139   2                              seg_bus[7]=(int)Set_Prepare%10;
 140   2                      break;
 141   2                      case 3:
 142   2                              seg_bus[0]=11;
 143   2                              seg_bus[1]=10;
 144   2                              seg_bus[2]=10;
 145   2                              seg_bus[3]=10;
 146   2                              seg_bus[4]=10;
 147   2                              seg_bus[5]=(int)V_out_show%10;
 148   2                                      seg_point[5]=1;
 149   2                              seg_bus[6]=(int)(V_out_show*10)%10;
 150   2                              seg_bus[7]=(int)(V_out_show*100)%10;
 151   2                      break;
 152   2              }
 153   1      }
 154          void T0_R(void) interrupt 1
 155          {
 156   1              if(++seg_slow_down==50) seg_slow_down=0;
 157   1              if(++key_slow_down==100) key_slow_down=0;
 158   1              if(++seg_num==8) seg_num=0;
 159   1              seg_show(seg_num,seg_bus[seg_num],seg_point[seg_num]);
 160   1              led_read(seg_num,led_bus[seg_num]);
 161   1              key_proc();
 162   1              seg_proc();
 163   1              led_proc();
 164   1      }
 165          void main()
 166          {
 167   1              system_init();
 168   1              Timer0Init();
 169   1              while(1)
 170   1              {
 171   2                      AD_proc();
 172   2                      Temperature=T_Read();
 173   2              }
 174   1      }
 175          unsigned char key_read()
 176          {
 177   1              unsigned char temp=0;
 178   1              ROW1=ROW2=ROW3=ROW4=1;
C51 COMPILER V9.59.0.0   MAIN                                                              03/31/2024 21:01:25 PAGE 4   

 179   1              COL1=0;COL2=COL3=COL4=1;
 180   1              if(ROW4==0) temp=4;
 181   1              if(ROW3==0) temp=5;
 182   1              ROW1=ROW2=ROW3=ROW4=1;
 183   1              COL2=0;COL1=COL3=COL4=1;
 184   1              if(ROW4==0) temp=8;
 185   1              if(ROW3==0) temp=9;
 186   1              return temp;
 187   1      }
 188          void led_read(unsigned char addr,enable)
 189          {
 190   1              unsigned char temp=0x00,temp_old=0xff;
 191   1              if(enable) 
 192   1                      temp|=0x01<<addr;
 193   1              else 
 194   1                      temp&=~(0x01<<addr);
 195   1              if(temp!=temp_old)
 196   1              {
 197   2                      P2 = P2 & 0x1f | 0x80;
 198   2                      P0 =~ temp;
 199   2                      P2 = P2 & 0x1f;
 200   2                      temp_old=temp;
 201   2              }
 202   1      }
 203          void system_init()
 204          {
 205   1              P2 = P2 & 0x1f | 0x80;
 206   1              P0 = 0xff;
 207   1              P2 = P2 & 0x1f | 0xa0;
 208   1              P0 = 0x00;
 209   1              P2 = P2 & 0x1f;
 210   1      }
 211          void seg_show(unsigned char wale,vula,point)
 212          {
 213   1              P2 = P2 & 0x1f | 0xc0;
 214   1              P0 = Seg_Wale[wale];
 215   1              P2 = P2 & 0x1f | 0xe0;
 216   1              P0 = Seg_Table[10];
 217   1              
 218   1              P2 = P2 & 0x1f | 0xc0;
 219   1              P0 = Seg_Wale[wale];
 220   1              P2 = P2 & 0x1f | 0xe0;
 221   1              P0 = 0xff;
 222   1              if(point) P0 &= 0x7f;
 223   1              P0 &= Seg_Table[vula];
 224   1              P2 = P2 & 0x1f;
 225   1              
 226   1      }
 227          void Timer0Init(void)           //1毫秒@12.000MHz
 228          {
 229   1              AUXR &= 0x7F;           //定时器时钟12T模式
 230   1              TMOD &= 0xF0;           //设置定时器模式
 231   1              TL0 = 0x18;             //设置定时初值
 232   1              TH0 = 0xFC;             //设置定时初值
 233   1              TF0 = 0;                //清除TF0标志
 234   1              TR0 = 1;                //定时器0开始计时
 235   1              EA =1;
 236   1              ET0 = 1;
 237   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.59.0.0   MAIN                                                              03/31/2024 21:01:25 PAGE 5   

   CODE SIZE        =   1098    ----
   CONSTANT SIZE    =     22    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     47       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
