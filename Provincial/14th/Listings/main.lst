C51 COMPILER V9.59.0.0   MAIN                                                              04/03/2024 23:24:09 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\keil5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.l
                    -st) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include <iic.h>
   3          #include <onewire.h>
   4          #include <ds1302.h>
   5          
   6          sbit COL1 = P4^4;
   7          sbit COL2 = P4^2;
   8          sbit COL3 = P3^5;
   9          sbit COL4 = P3^4;
  10          sbit ROW1 = P3^0;
  11          sbit ROW2 = P3^1;
  12          sbit ROW3 = P3^2;
  13          sbit ROW4 = P3^3;
  14          
  15          code unsigned char Seg_Wale[] ={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
  16          code unsigned char Seg_Table[] ={
  17          0xc0,//0
  18          0xf9,//1
  19          0xa4,//2
  20          0xb0,//3
  21          0x99,//4
  22          0x92,//5
  23          0x82,//6
  24          0xf8,//7
  25          0x80,//8
  26          0x90,//9
  27          0xff,//10
  28          0x88,//A 11
  29          0x83,//b 12
  30          0xc6,//C 13
  31          0xa1,//d 14
  32          0x86,//E 15
  33          0x8e,//F 16
  34          0xbf,//- 17
  35          0x89,//H 18
  36          0x8c//P  19
  37          };
  38          
  39          unsigned char seg_show_mod=0;           //0-时间界面 1-回显界面 2-参数界面 3-温湿度界面
  40          unsigned char huixian_mod=0;            //0-温度 1-湿度 2-时间
  41          unsigned char seg_slow_down,key_slow_down;
  42          unsigned char seg_num;
  43          unsigned char seg_bus[]={10,10,10,10,10,10,10,10};
  44          unsigned char seg_point[]={0,0,0,0,0,0,0,0};
  45          unsigned char led_bus[]={0,0,0,0,0,0,0,0};
  46          unsigned char key_val,key_old,key_down,key_up;
  47          xdata float freq,Shi_Du,Temperature;
  48          xdata int Temper_compare=30;
  49          unsigned int Timer_100,Timer_1000,Timer_2000,Timer_3000;
  50          unsigned char RB2_VO,RD1_VO=100;
  51          unsigned char Time[3]={21,31,58};       //h,m,s
  52          xdata float T_Rem[10],T_Max,T_AV=0.0;
  53          xdata float S_Rem[10],S_Max,S_AV=0.0;
  54          unsigned int chufa_num=0;
C51 COMPILER V9.59.0.0   MAIN                                                              04/03/2024 23:24:09 PAGE 2   

  55          unsigned char chufa_hour,chufa_min;
  56          bit chufa_flag,chufa_val,freq_con=0;
  57          bit init_flag,compare_big;
  58          
  59          void chufa_proc(void)
  60          {
  61   1              if(chufa_flag==0) RD1_VO=DA_Read(0x41);
  62   1              if((RD1_VO>=0)&&(RD1_VO<=20)) chufa_val=1;
  63   1              if(chufa_val)
  64   1              {
  65   2                      if((RD1_VO>=0)&&(RD1_VO<=20)) chufa_val=1;
  66   2                      else
  67   2                      {
  68   3                              chufa_flag=chufa_val;
  69   3                              chufa_hour=Time[0];
  70   3                              chufa_min=Time[1];
  71   3                              chufa_val=0;
  72   3                      }       
  73   2              }
  74   1      }
  75          void led_show(unsigned char addr,enable)
  76          {
  77   1              unsigned char temp=0x00,temp_old=0xff;
  78   1              if(enable)
  79   1                      temp |= 0x01<<addr;
  80   1              else
  81   1                      temp &=~ (0x01<<addr);
  82   1              if(temp!=temp_old)
  83   1              {
  84   2                      P2 = P2 & 0x1f | 0x80;//1000 4
  85   2                      P0 =~ temp;
  86   2                      P2 = P2 & 0x1f;
  87   2                      temp_old=temp;
  88   2              }
  89   1      }
  90          unsigned char key_read()
  91          {
  92   1              unsigned char i=0;
  93   1              ROW1=ROW2=ROW3=ROW4=1;
  94   1              COL1=0;COL2=COL3=COL4=1;
  95   1              if(ROW4==0) i = 4;
  96   1              if(ROW3==0) i = 5;
  97   1              ROW1=ROW2=ROW3=ROW4=1;
  98   1              COL2=0;COL1=COL3=COL4=1;
  99   1              if(ROW4==0) i = 8;
 100   1              if(ROW3==0) i = 9;
 101   1              return i;
 102   1      }
 103          void System_Init()
 104          {
 105   1              P2 = P2 & 0x1f | 0x80;//1000 4
 106   1              P0 = 0xff;
 107   1              P2 = P2 & 0x1f | 0xa0;//1010 5
 108   1              P0 = 0x00;
 109   1      }
 110          
 111          void seg_show(unsigned char wale,vula,point)
 112          {
 113   1              P2 = P2 & 0x1f | 0xc0;//1100 6
 114   1              P0 = Seg_Wale[wale];
 115   1              P2 = P2 & 0x1f | 0xe0;//1110 7
 116   1              P0 = Seg_Table[10];
C51 COMPILER V9.59.0.0   MAIN                                                              04/03/2024 23:24:09 PAGE 3   

 117   1              
 118   1              P2 = P2 & 0x1f | 0xc0;//1100 6
 119   1              P0 = Seg_Wale[wale];
 120   1              P2 = P2 & 0x1f | 0xe0;//1110 7
 121   1              P0 = Seg_Table[10];
 122   1              if(point) P0 &= 0x7f;
 123   1              P0 &= Seg_Table[vula];
 124   1              P2 = 0x1f;
 125   1      }
 126          void led_proc()
 127          {
 128   1              if(seg_show_mod==0) led_bus[0]=1;
 129   1              else led_bus[0]=0;
 130   1              if(seg_show_mod==1) led_bus[1]=1;
 131   1              else led_bus[1]=0;
 132   1              if(seg_show_mod==2) led_bus[2]=1;
 133   1              else led_bus[2]=0;
 134   1              if((int)T_Rem[chufa_num-1]>Temper_compare) compare_big=1;
 135   1              else compare_big=0;
 136   1              if(Shi_Du==0&&chufa_num!=0)  led_bus[4]=1;
 137   1              if(chufa_num>=2&&T_Rem[chufa_num-1]>T_Rem[chufa_num-2]&&S_Rem[chufa_num-1]>S_Rem[chufa_num-2])
 138   1              led_bus[5]=1;
 139   1              else led_bus[5]=0;
 140   1      }
 141          void key_proc()
 142          {
 143   1              unsigned int i;
 144   1              if(key_slow_down) return;
 145   1              key_slow_down=1;
 146   1              
 147   1              chufa_proc();
 148   1              
 149   1              key_val = key_read();
 150   1              key_down = key_val & (key_val ^ key_old);
 151   1              key_up =~ key_val & (key_val ^ key_old);
 152   1              key_old = key_val;
 153   1              
 154   1              switch(key_down)
 155   1              {
 156   2                      case 4:
 157   2                              seg_show_mod++;
 158   2                              if(seg_show_mod==3) seg_show_mod=0;
 159   2                              huixian_mod=0;
 160   2                      break;
 161   2                      case 5:
 162   2                              if(seg_show_mod==1)
 163   2                              {
 164   3                                      huixian_mod++;
 165   3                                      if(huixian_mod==3) huixian_mod=0;
 166   3                              }
 167   2                      break;
 168   2                      case 8:
 169   2                              if(seg_show_mod==2) Temper_compare++;
 170   2                              if(Temper_compare==100) Temper_compare=0;
 171   2                      break;
 172   2                      case 9:
 173   2                              if(seg_show_mod==2) Temper_compare--;
 174   2                              if(Temper_compare==-1) Temper_compare=99;
 175   2                              if(seg_show_mod==1&&huixian_mod==2) 
 176   2                              {
 177   3                                      Timer_2000=0;
 178   3                                      init_flag=1;
C51 COMPILER V9.59.0.0   MAIN                                                              04/03/2024 23:24:09 PAGE 4   

 179   3                              }
 180   2                      break;
 181   2              }
 182   1              if(key_up==9) 
 183   1              {
 184   2                      Timer_2000=0;
 185   2                      if(init_flag==0)
 186   2                      {
 187   3                              for(i=0;i<10;i++)
 188   3                              {
 189   4                                      T_Rem[i]=0.0;
 190   4                                      S_Rem[i]=0.0;
 191   4                              }
 192   3                              T_Rem[10],T_Max=0.0;T_AV=0.0;
 193   3                              S_Rem[10],S_Max=0.0;S_AV=0.0;
 194   3                              chufa_num=0;
 195   3                              chufa_hour=chufa_min=0;
 196   3                      }
 197   2                      init_flag=0;
 198   2              }
 199   1      }
 200          void seg_proc()
 201          {
 202   1              unsigned char i;
 203   1              if(seg_slow_down) return;
 204   1              seg_slow_down=1;
 205   1              
 206   1              //RB2_VO=DA_Read(0x43);
 207   1              //RD1_VO=DA_Read(0x41);
 208   1              switch(seg_show_mod)
 209   1              {
 210   2                      case 0:
 211   2                              Rtc_Read(Time);
 212   2                              seg_bus[0]=(int)Time[0]/10;
 213   2                              seg_bus[1]=(int)Time[0]%10;
 214   2                              
 215   2                              seg_bus[3]=(int)Time[1]/10;
 216   2                              seg_bus[4]=(int)Time[1]%10;
 217   2                              
 218   2                              seg_bus[6]=(int)Time[2]/10;
 219   2                              seg_bus[7]=(int)Time[2]%10;
 220   2                      break;
 221   2                      
 222   2                      case 1:
 223   2                              if(huixian_mod==0)      //温度
 224   2                              {
 225   3                                      seg_bus[0]=13;
 226   3                                      seg_bus[1]=10;
 227   3                                      seg_bus[2]=(int)T_Max/10%10;
 228   3                                      seg_bus[3]=(int)T_Max%10;
 229   3                                      seg_bus[4]=17;
 230   3                                      seg_bus[5]=(int)T_AV/100%10;
 231   3                                      seg_bus[6]=(int)T_AV/10%10;
 232   3                                      seg_point[6]=1;
 233   3                                      seg_bus[7]=(int)T_AV%10;
 234   3                              }
 235   2                              if(huixian_mod==1)      //湿度
 236   2                              {
 237   3                                      seg_bus[0]=18;
 238   3                                      seg_bus[1]=10;
 239   3                                      seg_bus[2]=(int)S_Max/10%10;
 240   3                                      seg_bus[3]=(int)S_Max%10;
C51 COMPILER V9.59.0.0   MAIN                                                              04/03/2024 23:24:09 PAGE 5   

 241   3                                      seg_bus[4]=17;
 242   3                                      seg_bus[5]=(int)S_AV/100%10;
 243   3                                      seg_bus[6]=(int)S_AV/10%10;
 244   3                                      seg_point[6]=1;
 245   3                                      seg_bus[7]=(int)S_AV%10;
 246   3                              }
 247   2                              if(huixian_mod==2)      //时间
 248   2                              {
 249   3                                      seg_point[6]=0;
 250   3                                      seg_bus[0]=16;
 251   3                                      seg_bus[1]=(int)chufa_num/10%10;
 252   3                                      seg_bus[2]=(int)chufa_num%10;
 253   3                                      seg_bus[3]=(int)chufa_hour/10%10;
 254   3                                      seg_bus[4]=(int)chufa_hour%10;
 255   3                                      seg_bus[5]=17;
 256   3                                      seg_bus[6]=(int)chufa_min/10%10;
 257   3                                      seg_bus[7]=(int)chufa_min%10;
 258   3                              }
 259   2                      break;
 260   2                              
 261   2                      case 2:
 262   2                              for(i=0;i<8;i++)
 263   2                              {
 264   3                                      seg_point[i]=0;
 265   3                                      seg_bus[i]=10;
 266   3                              }
 267   2                              seg_bus[0]=19;
 268   2                              seg_bus[6]=(int)Temper_compare/10%10;
 269   2                              seg_bus[7]=(int)Temper_compare%10;
 270   2                      break;
 271   2                              
 272   2                      case 3:
 273   2                              for(i=0;i<8;i++)
 274   2                              {
 275   3                                      seg_point[i]=0;
 276   3                                      seg_bus[i]=10;
 277   3                              }
 278   2                              seg_bus[0]=15;
 279   2                              seg_bus[3]=(int)T_Rem[chufa_num]/10%10;
 280   2                              seg_bus[4]=(int)T_Rem[chufa_num]%10;
 281   2                              seg_bus[5]=17;
 282   2                              seg_bus[6]=(int)S_Rem[chufa_num]/10%10;
 283   2                              seg_bus[7]=(int)S_Rem[chufa_num]%10;
 284   2                              
 285   2                              if(Shi_Du==0)
 286   2                              {
 287   3                                      seg_bus[6]=11;
 288   3                                      seg_bus[7]=11;
 289   3                              }
 290   2                      break;
 291   2                      case 4:
 292   2                              seg_bus[0]=chufa_val;
 293   2                              seg_bus[1]=chufa_flag;
 294   2                              seg_bus[5]=(int)RD1_VO/100%10;
 295   2                              seg_bus[6]=(int)RD1_VO/10%10;
 296   2                              seg_bus[7]=(int)RD1_VO%10;
 297   2                      break;
 298   2              }
 299   1              
 300   1      }
 301          void Timer1Init(void)           //1毫秒@12.000MHz
 302          {
C51 COMPILER V9.59.0.0   MAIN                                                              04/03/2024 23:24:09 PAGE 6   

 303   1              AUXR &= 0xBF;           //定时器时钟12T模式
 304   1              TMOD &= 0x0F;           //设置定时器模式
 305   1              TL1 = 0x18;             //设置定时初值
 306   1              TH1 = 0xFC;             //设置定时初值
 307   1              TF1 = 0;                //清除TF1标志
 308   1              TR1 = 1;                //定时器1开始计时
 309   1              ET1 = 1;
 310   1              EA = 1;
 311   1      }
 312          void Timer0Init(void)           //1毫秒@12.000MHz
 313          {
 314   1              TMOD &= 0xF0;           //设置定时器模式
 315   1              TMOD |= 0x05;
 316   1              TL0 = 0x00;             //设置定时初值
 317   1              TH0 = 0x00;             //设置定时初值
 318   1              TF0 = 0;                //清除TF0标志
 319   1              TR0 = 1;                //定时器0开始计时
 320   1              ET0 = 1;
 321   1              EA = 1;
 322   1      }
 323          
 324          void T1_R(void) interrupt 3
 325          {
 326   1              unsigned char i,state_old;
 327   1              if(++seg_slow_down==50) seg_slow_down=0;
 328   1              if(++key_slow_down==60) key_slow_down=0;
 329   1              if(++seg_num==8) seg_num=0;
 330   1              seg_show(seg_num,seg_bus[seg_num],seg_point[seg_num]);
 331   1              led_show(seg_num,led_bus[seg_num]);
 332   1              if(freq_con==1)
 333   1              if(++Timer_1000==1000)
 334   1              {
 335   2                      Timer_1000=0;
 336   2                      freq = (TH0<<8)|TL0;
 337   2                      Shi_Du = 2*freq/45.0 + (10.0/9.0);
 338   2                      if(Shi_Du>90||Shi_Du<10) Shi_Du=0;
 339   2                      TH0=TL0=0;
 340   2              }
 341   1              if(chufa_flag==1)
 342   1              {
 343   2                      if(seg_show_mod!=3) 
 344   2                      {
 345   3                              state_old=seg_show_mod;
 346   3                              T_Rem[chufa_num]=Temperature;
 347   3                              S_Rem[chufa_num]=Shi_Du;                        
 348   3                      }
 349   2                      freq_con=1;
 350   2                      seg_show_mod=3;
 351   2                      if(++Timer_3000==3000)
 352   2                      {
 353   3                              Timer_3000=0;
 354   3                              chufa_flag=0;
 355   3                              
 356   3                              T_AV=S_AV=0.0;
 357   3                              for(i=0;i<=chufa_num;i++)
 358   3                              {
 359   4                                      T_AV+=T_Rem[i];
 360   4                                      S_AV+=S_Rem[i];
 361   4                                      if(T_Rem[chufa_num]>=T_Rem[i]) T_Max=T_Rem[chufa_num];
 362   4                                      if(S_Rem[chufa_num]>=S_Rem[i]) S_Max=S_Rem[chufa_num];
 363   4                              }
 364   3                              chufa_num++;
C51 COMPILER V9.59.0.0   MAIN                                                              04/03/2024 23:24:09 PAGE 7   

 365   3                              T_AV=T_AV*10/chufa_num*1.0;
 366   3                              S_AV=S_AV*10/chufa_num*1.0;
 367   3                              
 368   3                              seg_show_mod=state_old;
 369   3                              freq_con=0;
 370   3                      }
 371   2              }
 372   1              if(init_flag==1)
 373   1              {
 374   2                      if(++Timer_2000==2000)
 375   2                      {
 376   3                              Timer_2000=0;
 377   3                              init_flag=0;
 378   3                      }
 379   2              }
 380   1              if(compare_big==1)
 381   1              {
 382   2                      if(++Timer_100==100)
 383   2                      {
 384   3                              Timer_100=0;
 385   3                              led_bus[3]^=1;
 386   3                      }
 387   2              }
 388   1              seg_proc();
 389   1              key_proc();
 390   1      }
 391          void main()
 392          {
 393   1              System_Init();
 394   1              Timer0Init();
 395   1              Timer1Init();
 396   1              Rtc_Write(Time);
 397   1              while(1)
 398   1              {
 399   2                      freq_con=1;
 400   2                      led_proc();
 401   2                      Temperature=Temperature_Read();
 402   2              }
 403   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2913    ----
   CONSTANT SIZE    =     28    ----
   XDATA SIZE       =    110    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     50       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
